<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Exhibition Navigator — Map</title>
  <style>
    :root{--bg:#0f172a;--panel:#0b1220;--accent:#60a5fa}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:#e6eef8}
    .app{height:100vh;display:flex;flex-direction:column}
    header{padding:12px 16px;display:flex;align-items:center;gap:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent)}
    header h1{font-size:16px;margin:0}
    main{flex:1;display:flex}
    /* map column */
    .map-column{flex:1;display:flex;align-items:stretch;justify-content:center;padding:12px}
    /* container that holds SVG — we will transform this element */
    #mapContainer{width:100%;height:100%;max-width:1400px;max-height:100%;background:#081026;border-radius:8px;overflow:hidden;position:relative;touch-action:none}
    /* center the SVG inside container */
    #mapWrapper{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    svg{max-width:100%;max-height:100%;display:block;user-select:none;pointer-events:auto}

    /* controls */
    .panel{width:320px;background:var(--panel);padding:12px;border-left:1px solid rgba(255,255,255,0.02)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#0b1220;color:#e6eef8;border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px;cursor:pointer}
    small.hint{display:block;margin-top:8px;color:#9fb4d9}
    footer{padding:8px 12px;font-size:12px;color:#9fb4d9;background:linear-gradient(0deg,transparent,rgba(255,255,255,0.01))}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Exhibition Navigator — Map Viewer</h1>
      <div style="margin-left:auto;opacity:0.9">Firman — MapController refactor</div>
    </header>

    <main>
      <div class="map-column">
        <div id="mapContainer">
          <div id="mapWrapper" aria-hidden="false">
            <!-- SVG will be loaded here via JS (keeps HTML clean and lets JS wire handlers) -->
            <div id="loading" style="color:#7ea2ff;padding:10px">Loading map…</div>
          </div>
        </div>
      </div>

      <aside class="panel">
        <div style="margin-bottom:8px"><strong>Controls</strong></div>
        <div class="controls">
          <button id="zoomIn">Zoom +</button>
          <button id="zoomOut">Zoom -</button>
          <button id="reset">Reset</button>
          <button id="fit">Fit to view</button>
        </div>
        <small class="hint">Drag to pan. Scroll to zoom. Pinch to zoom on mobile. Interaction uses Pointer Events + inertial panning.</small>
        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.02)" />
        <div><strong>Diagnostics</strong></div>
        <div id="debug" style="margin-top:8px;font-size:12px;color:#9fb4d9">status: idle</div>
      </aside>
    </main>

    <footer>
      Built with ❤️ — MapController + smooth pan/zoom + pinch + inertia
    </footer>
  </div>

  <script type="module">
    // MapController: encapsulates pan/zoom behavior for an SVG or any element
    class MapController {
      constructor(container, options = {}) {
        this.container = container; // element that contains the SVG
        this.wrapper = container.querySelector('#mapWrapper');
        this.svg = null; // will be set once SVG is loaded

        // transform state
        this.scale = options.initialScale ?? 1;
        this.x = options.initialX ?? 0; // translation in px
        this.y = options.initialY ?? 0;

        // interaction state
        this.isPanning = false;
        this.pointers = new Map(); // pointerId -> {x,y}
        this.lastMoves = []; // recent moves for velocity calc
        this.velocity = { x: 0, y: 0 };
        this.animFrame = null;

        // limits
        this.minScale = options.minScale ?? 0.2;
        this.maxScale = options.maxScale ?? 5;

        // smoothness
        this.friction = options.friction ?? 0.92; // inertia deceleration
        this.velocityThreshold = options.velocityThreshold ?? 0.05;

        // debugging hook
        this.debugEl = document.getElementById('debug');

        // bind handlers
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onWheel = this.onWheel.bind(this);

        // init
        this.init();
      }

      logDebug(txt){ if(this.debugEl) this.debugEl.textContent = txt }

      async init() {
        // load the SVG (attempt to find <svg> inside mapWrapper or fetch map.svg)
        const existingSvg = this.wrapper.querySelector('svg');
        if (existingSvg) {
          this.svg = existingSvg;
        } else {
          // try to fetch map.svg from repo root (adjust path if needed)
          try {
            const resp = await fetch('/map.svg');
            if (!resp.ok) throw new Error('map.svg not found');
            const text = await resp.text();
            this.wrapper.innerHTML = text;
            this.svg = this.wrapper.querySelector('svg');
          } catch (err) {
            // If fetch fails, keep the loading message
            this.logDebug('Failed loading map.svg — check path.');
            console.warn(err);
            return;
          }
        }

        // prepare svg & styles
        this.svg.style.touchAction = 'none'; // disable default gestures
        this.svg.style.userSelect = 'none';
        this.svg.style.transformOrigin = '0 0';

        // initialize transform
        this.applyTransform();

        // pointer events
        this.svg.addEventListener('pointerdown', this.onPointerDown, { passive: false });
        window.addEventListener('pointermove', this.onPointerMove, { passive: false });
        window.addEventListener('pointerup', this.onPointerUp, { passive: false });
        window.addEventListener('pointercancel', this.onPointerUp, { passive: false });

        // wheel zoom
        this.svg.addEventListener('wheel', this.onWheel, { passive: false });

        // control buttons
        document.getElementById('zoomIn').addEventListener('click', () => this.zoomBy(1.2));
        document.getElementById('zoomOut').addEventListener('click', () => this.zoomBy(1/1.2));
        document.getElementById('reset').addEventListener('click', () => this.reset());
        document.getElementById('fit').addEventListener('click', () => this.fitToView());

        this.logDebug('map loaded');
      }

      // converts client coords to local (before transform)
      clientToLocal(clientX, clientY) {
        const rect = this.svg.getBoundingClientRect();
        const x = (clientX - rect.left - this.x) / this.scale;
        const y = (clientY - rect.top - this.y) / this.scale;
        return { x, y };
      }

      applyTransform() {
        // apply translate then scale
        // Use translate3d to trigger GPU acceleration
        this.svg.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) scale(${this.scale})`;
      }

      onPointerDown(e) {
        // capture pointer
        this.svg.setPointerCapture?.(e.pointerId);
        this.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (this.pointers.size === 1) {
          // start single pointer pan
          this.isPanning = true;
          this.lastMoves = [{t: performance.now(), x: e.clientX, y: e.clientY}];
          // stop any inertia
          this.stopAnim();
        }

        if (this.pointers.size === 2) {
          // pinch start: record initial distance & midpoint
          const pts = Array.from(this.pointers.values());
          this.pinchStart = {
            dist: this.distance(pts[0], pts[1]),
            scale: this.scale,
            midpoint: { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 }
          };
        }

        e.preventDefault();
      }

      onPointerMove(e) {
        if (!this.pointers.has(e.pointerId)) return;
        const prev = this.pointers.get(e.pointerId);
        const cur = { x: e.clientX, y: e.clientY };
        this.pointers.set(e.pointerId, cur);

        if (this.pointers.size === 1 && this.isPanning) {
          const dx = cur.x - prev.x;
          const dy = cur.y - prev.y;

          this.x += dx;
          this.y += dy;
          this.applyTransform();

          // save move sample for velocity
          this.lastMoves.push({ t: performance.now(), x: cur.x, y: cur.y });
          // keep last 10 samples
          if (this.lastMoves.length > 10) this.lastMoves.shift();
        }

        if (this.pointers.size === 2) {
          // handle pinch zoom
          const pts = Array.from(this.pointers.values());
          const dist = this.distance(pts[0], pts[1]);
          const midpoint = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };

          const factor = dist / this.pinchStart.dist;
          const newScale = this.clamp(this.pinchStart.scale * factor, this.minScale, this.maxScale);

          // compute local coords around midpoint
          const localBefore = this.clientToLocal(this.pinchStart.midpoint.x, this.pinchStart.midpoint.y);
          const localAfter = this.clientToLocal(midpoint.x, midpoint.y);

          // adjust translation so the midpoint stays under the same content point
          // transform: x' = midpointClient - local*scale'
          const rect = this.svg.getBoundingClientRect();
          const clientMidX = midpoint.x - rect.left;
          const clientMidY = midpoint.y - rect.top;

          this.scale = newScale;
          // recompute x,y to keep content stable under midpoint
          this.x = clientMidX - localAfter.x * this.scale;
          this.y = clientMidY - localAfter.y * this.scale;

          this.applyTransform();
        }

        e.preventDefault();
      }

      onPointerUp(e) {
        if (!this.pointers.has(e.pointerId)) return;
        // remove pointer
        this.pointers.delete(e.pointerId);

        if (this.pointers.size === 0 && this.isPanning) {
          // compute velocity from lastMoves
          const len = this.lastMoves.length;
          if (len >= 2) {
            const a = this.lastMoves[0];
            const b = this.lastMoves[len - 1];
            const dt = (b.t - a.t) / 1000; // seconds
            if (dt > 0) {
              const vx = (b.x - a.x) / dt;
              const vy = (b.y - a.y) / dt;
              this.velocity.x = vx;
              this.velocity.y = vy;
              // start inertia
              this.startInertia();
            }
          }
        }

        // reset pan state
        if (this.pointers.size === 0) {
          this.isPanning = false;
        }

        e.preventDefault();
      }

      onWheel(e) {
        e.preventDefault();
        // zoom towards cursor
        const delta = -e.deltaY;
        const zoomFactor = delta > 0 ? 1.08 : 1/1.08;
        const rect = this.svg.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;

        const before = { x: (cx - this.x) / this.scale, y: (cy - this.y) / this.scale };
        const newScale = this.clamp(this.scale * zoomFactor, this.minScale, this.maxScale);

        this.scale = newScale;
        this.x = cx - before.x * this.scale;
        this.y = cy - before.y * this.scale;

        this.applyTransform();
      }

      startInertia() {
        if (this.animFrame) cancelAnimationFrame(this.animFrame);
        const step = () => {
          // apply velocity
          this.x += this.velocity.x * (1/60); // assume 60fps -> px per frame
          this.y += this.velocity.y * (1/60);

          // apply friction
          this.velocity.x *= this.friction;
          this.velocity.y *= this.friction;

          // stop condition
          if (Math.abs(this.velocity.x) < this.velocityThreshold && Math.abs(this.velocity.y) < this.velocityThreshold) {
            this.velocity.x = 0; this.velocity.y = 0; this.applyTransform(); this.animFrame = null; return;
          }

          this.applyTransform();
          this.animFrame = requestAnimationFrame(step);
        };
        this.animFrame = requestAnimationFrame(step);
      }

      stopAnim(){ if (this.animFrame) cancelAnimationFrame(this.animFrame); this.animFrame = null; this.velocity = {x:0,y:0}; }

      zoomBy(factor) {
        // center on container center
        const rect = this.svg.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        const before = { x: (cx - this.x) / this.scale, y: (cy - this.y) / this.scale };
        const newScale = this.clamp(this.scale * factor, this.minScale, this.maxScale);
        this.scale = newScale;
        this.x = cx - before.x * this.scale;
        this.y = cy - before.y * this.scale;
        this.applyTransform();
      }

      reset() {
        this.scale = 1; this.x = 0; this.y = 0; this.applyTransform();
      }

      fitToView() {
        // naive fit: scale to fit container while preserving aspect
        const svgBBox = this.svg.viewBox.baseVal;
        // if viewBox not set, try bounding box
        let vbw = svgBBox && svgBBox.width ? svgBBox.width : this.svg.clientWidth;
        let vbh = svgBBox && svgBBox.height ? svgBBox.height : this.svg.clientHeight;
        const rect = this.container.getBoundingClientRect();
        const scaleX = rect.width / vbw;
        const scaleY = rect.height / vbh;
        this.scale = Math.min(scaleX, scaleY) * 0.95; // small padding
        // center
        this.x = (rect.width - vbw * this.scale) / 2;
        this.y = (rect.height - vbh * this.scale) / 2;
        this.applyTransform();
      }

      clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
    }

    // Instantiate controller for #mapContainer
    (function(){
      const container = document.getElementById('mapContainer');
      const controller = new MapController(container, { initialScale: 1, minScale: 0.3, maxScale: 6 });

      // expose on window for debugging if needed (optional)
      window._MapController = controller;
    })();
  </script>
</body>
</html>
